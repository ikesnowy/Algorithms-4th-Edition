// 假设以下所有 log 运算的底数均为 t。
// 首先考虑简单的 sink 实现。
// sink 方法会在所有的 t 个子结点中寻找最大的结点。
// 如果找到的结点比当前结点大，那么就进行交换。
// 否则视为结点已经下沉到了合适的位置，结束循环。
// 根据题意，在 t 个元素中找最大值需要 t 次比较。
// sink 操作需要找到 t 个子结点中的最大值并与当前结点相比较。
// 于是 sink 操作每次需要使用 (t + 1) 次比较。

// 建堆过程
// 对 2.4.20 的证明进行推广，
// 建堆最多需要 n 次交换，(t + 1)n 次比较
// 排序过程
// 每次删除最大元素的操作都会对根结点调用一次 sink
// 故排序过程需要的比较次数为 n(t + 1) logn
// 总共需要的比较次数为：n(t + 1) + n(t + 1) logn = (t + 1)(nlogn + n)
// 接下来我们利用换底公式将对数的底换成 2，lg 表示以 2 为底的对数。
// 原式 = [(t + 1)/(lg t)](nlgn + nlgt)
// 由于考虑的是 nlgn 的系数，于是问题转化为求
// (t+1)/lgt 的最小值，t > 1
// 直接求解比较困难，
// 考虑到 lg t 的导数 1/(tln2) 从 t=2 开始就小于 t+1 的导数。
// 故简单尝试可以发现最小值点在 t=3 和 t=4 之间。
// 计算结果为 t=4 时取最小，系数为 2.5。

// 再考虑使用 Floyd 方法优化 sink 方法的情况
// sink 方法使用的比较次数变为 t
// 建堆需要的比较次数变为 tn
// 排序需要的比较次数变为 tnlogn
// 总共需要的比较次数为 t(nlogn + n)
// 同样转化为求 t/lgt 的最小值。
// 计算结果为 t=3 时取最小，系数为 1.89。

return;