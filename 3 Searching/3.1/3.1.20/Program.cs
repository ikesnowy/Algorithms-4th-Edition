// 二分查找的路径可以展开为一个二叉树，
// 查找次数就等于二叉树的深度，由二叉树性质得 C(N) <= lgN + 1。
// 也可以这么证明：
// 已知当 N=0 时，有 C(0) < C(1)
// 假设当 N=n 时，有 C(n) < C(n+1)
// 根据递归式，有：
// C(n)   <= C([n/2]) + 1   ( [] 代表下取整，下同）
// C(n+1) <= C([n/2]) + 1           n 是偶数
//           C([n/2] + 1) + 1       n 是奇数
// C(n+2) <= C([n/2] + 1) + 1
// 又 C(n) <= C(n+1)，于是 C([n/2]) <= C([n/2] + 1)。
// 故 C(n+1) <= C(n+2)，由数学归纳法，C(n) 单调递增。
// 
// 国内中英文版算法中关于命题 B 的证明均有错误
// 最新印刷的版本已经修复了这个错误，详情见：https://alg4.ikesnowy.com/3-1-20/
// 根据命题 B 已经给出的结论，
// 已知当 N=2^k - 1 时，C(N) <= k <= lgN + 1
// 设 0<M<2^k，即 1<=M<=2^k-1，于是 2^k-1 < N+M < 2^(k+1) -1
// 只要证明 C(N+M) <= lg(N+M)+1 即可证明命题 B
// 由于 C(N+M) 是一个整数，等同于证 C(N+M) <= [lg(N+M)]+1 = k+1
// 由单调性可得 C(N+M) <= C(2^(k+1)-1) <= k+1，
// 得证。

return;